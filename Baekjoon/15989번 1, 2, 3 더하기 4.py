# 백준 15989번 1, 2, 3 더하기 4 문제 (골드5)
# https://www.acmicpc.net/problem/15989

'''
처음에는 큰 값부터 처리하는 greedy 알고리즘이 떠올랐는데, 풀이하기가 어려웠다.
더 생각해보니 DP 문제같은데, D[n]에 매번 완전한 결과 값을 저장하는 식으로 접근해서 틀렸다.
1부터 n까지 +2을 하는 경우를 순차적으로 계산한 다음, +3을 하는 경우를 순차적으로 계산해야했다.
+2과 +3 경우를 먼저 계산해놓으면 +1 경우를 따로 계산할 필요가 없다는 것도 파악하기 어려웠다.


풀이:

각 n값을 1로만 나타내는 경우의 수가 항상 존재하므로 1로 초기화, D[n] = 1
+2 을 하는 경우의 수는 D[n] += D[n-2]
+3 을 하는 경우의 수는 D[n] += D[n-3]
+1 을 하는 경우의 수는 +2 와 +3 경우의 수에 다 포함되기 때문에 처리할 필요 없음.

예시:

1로만 나타내는 경우 (D[n] = 1)
0: 0
1: 1
2: 1+1
3: 1+1+1
4: 1+1+1+1

+2을 하는 경우 (D[n] += D[n-2])
0: (0)
1: (1)
2: (1+1), 2
3: (1+1+1), 1+2
4: (1+1+1+1), 1+1+2, 2+2

+3을 하는 경우 (D[n] += D[n-3])
0: (0)
1: (1)
2: (1+1, 2)
3: (1+1+1, 1+2), 3
4: (1+1+1+1, 1+1+2, 2+2), 1+3

# n=4일 때, n-1(=3)에다가 +1을 하는 경우를 생각해보면 이미 다 포함되어 있으므로 처리할 필요가 없음
'''

T = int(input())
inputs = [int(input()) for _ in range(T)]

D = [1] * 10001

for i in range(2, max(inputs)+1):
    D[i] += D[i-2]

for i in range(3, max(inputs)+1):
    D[i] += D[i-3]

for n in inputs:
    print(D[n])